// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=//
// Адресная арифметика в массивах
// arrAdrAri.cpp ReferencesPointers
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=//
#include<iostream>
using namespace std;

/*
ptr + 1 не возвращает следующий любой адрес памяти, который находится сразу
после ptr, но он возвращает адрес памяти следующего объекта, тип которого
совпадает с типом значения, на которое указывает ptr
*/

int main() {
    int array[] {7, 8, 2, 4, 5};
    cout << "Адрес 1-го элемента: " << &array[1] << '\n';
    cout << "То же самое:         " << array+1 << '\n'; // Потому, что array+1 это 0-й элемент + 1
    cout << "Значение 1-го элемента: " << array[1] << '\n';
    cout << "Значение 1-го элемента через разыменование:  " << *(array+1) << '\n';
    char name[] = "Jonathan";
    char *ptr = name;
    cout << "Размер массива name: " << sizeof(name) << '\n';
    cout << "Что-то: " << ptr << '\n';
    cout << "Что-то: " << &ptr << '\n';
    cout << "Что-то: " << *ptr << '\n';
    cout << "Что-то: " << sizeof(*ptr) << '\n';
    return 0;
}
// Output
/*

*/
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- //
// END FILE
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- //