// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=//
// Составные тимы: указатели и ссылки
// refPoint.cpp ReferencesPointers
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=//
#include<iostream>
using namespace std;

/*
1. Ссылка - не объект, а только другое имя уже существующего объекта (псевдоним);
2. Поскольку ссылки не объекты, нельзя определить ссылку на ссылку;
3. Поскольку ссылки не объекты, у них нет адресов;
4. Типы ссылки и объекта, на который она ссылается, должны совпадать точно;
5. Ссылка может быть связана только с объектом, а не с литералом (Литерал - это элемент программы, который представляет значение);
6. Ссылки всегда следует инициализировать!
7. Ссылка не может быть изменена после её инициализации.

1. Указатель - это настоящий объект!
2. Уазатель - это переменная, которая хранит только адрес другой переменной;
3. Указатель содержит только адрес, но между указателем и содержащимся в нём адресом нет жесткой связи;
4. Одному указателю можно присваивать разные значения;
5. Указатель всегда должен иметь тип, но тип указателя всегда должен соответствовать типу указываемой переменной;
6. Указатели в языке C++ по своей природе являются небезопасными;
7. С 64-битным исполняемым файлом указатель всегда будет занимать 64 бита (8 байт);
8. Указатель можно не инициализировать (но лучше так не делать!). Используйте nullptr для C++, если заранее не известно значение указателя ;
9. Указателю нельзя присвоить адрес памяти на прямую;
*/

int main() {
    int a = 7;
    cout << a << endl; // Выводим значение переменной
    cout << "Адрес ссылки\n";
    cout << &a << endl; // Выводим адрес переменной в оперативной памяти компьютера
    cout << "Функция-близнец знака ссылки (амперсэнта (&))\n";
    cout << addressof(a) << '\n';
    // Оператор разыменования * позволяет получить значение по указанному адресу:
    cout << "Выводим значение ячейки памяти переменной\n";
    cout << *&a << endl;
    int *ptr; // Указатель на значение типа int
    double *dptr; // Указатель на значение типа double
    int *iptr1, *iptr2; // Объявляем 2-а указателя типа int
    cout << "Выводим адреса указателей: \n";
    cout << ptr << ' ' << dptr << ' ' << iptr1 << ' ' << iptr2 << endl;
    // Указатели содержат только адреса!
    int val = 5;
    int *vptr = &val; // Инициализируем vptr адресом значения переменной
    // vptr указывает на адрес значения переменной
    cout << "Адреса у переменной и указателя одинаковые\n";
    cout << &val << ' ' << vptr << " Значение *vprt = " << *vptr << endl;
    // Разыменованный указатель - это содержимое ячейки памяти, на которую он ссылается
    // Тип указателя всегда должен соответствовать типу указываемой переменной
    int iVal = 7;
    double dVal = 9.0;
    int *iPoint = &iVal;
    double *dPoint = &dVal;
    cout << "Выводим значения адресов переменных\n";
    cout << *iPoint << ' ' << *dPoint << endl;
    /* разыменование указателя означает, что нужно «перейти к адресу, на который указывает
    указатель, и достать из этого адреса значение */
    //int *nptr = 7; // Так нельзя!
    //double *nDptr = 0x0012FF7C; // Так нельзя!
    cout << "Определяем тип переменной\n";
    int x = 4;
    cout << typeid(&x).name() << endl; // С оператором адреса
    cout << typeid(x).name() << endl;
    //free(dPoint); // Что за неведомая штука?
    cout << "Разыменование указателей\n";
    int five = 5;
    cout << "Выводим адрес переменной: " << &five << '\n';
    cout << "Выводим содержимое переменной: " << five << '\n';
    int *fivePtr = &five;
    cout << "Выводим адрес fivePtr: " << fivePtr << '\n';
    cout << "Разыменовываем (получаем значение, на которое указывает fivePtr): " << *fivePtr << '\n';
    cout << "Одному указателю можно присваивать разные значения\n";
    int value1 = 1, value2 = 2;
    int *vvPtr;
    vvPtr = &value1;
    cout << "vvPtr содержит адрес value1: " << vvPtr << " и значение: " << *vvPtr << '\n';
    vvPtr = &value2;
    cout << "vvPtr теперь содержит адрес value2: " << vvPtr << " и значение: " << *vvPtr << '\n';
    cout << "Размер указателей\n";
    char *chPtr;
    int *iIptr;
    double *dPtr;
    cout << "Размер указателя char: " << sizeof(chPtr) << '\n'; // 8 байт
    cout << "Размер указателя int: " << sizeof(iIptr) << '\n'; // 8 байт
    cout << "Размер указателя double: " << sizeof(dPtr) << '\n'; // 8 байт


    return 0;
}
// Output
/*
7
0x7fffd1d98e68
Выводим значение ячейки памяти переменной
7
Выводим адреса указателей:
0x7fffd1d98f60 0x401130 0 0x401850
Адреса у переменной и указателя одинаковыеt
0x7fffd1d98e44 0x7fffd1d98e44 Значение *vprt = 5
Выводим значения адресов переменных
7 9
Определяем тип переменной
Pi
i
Разыменование указателей
Выводим адрес переменной: 0x7fffd1d98e10
Выводим содержимое переменной: 5
Выводим адрес fivePtr: 0x7fffd1d98e10
Разыменовываем (получаем значение, на которое указывает fivePtr): 5
Одному указателю можно присваивать разные значения
vvPtr содержит адрес value1: 0x7fffd1d98e04 и значение: 1
vvPtr теперь содержит адрес value2: 0x7fffd1d98e00 и значение: 2
Размер указателей
Размер указателя char: 8
Размер указателя int: 8
*/
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- //
// END FILE
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- //
