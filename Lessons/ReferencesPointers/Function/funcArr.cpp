// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=//
// Указатели и функции
// funcRefPoint.cpp
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=//
#include<iostream>
using namespace std;

/*
1. Во многих случаях при вычислении фиксированный массив распадается (неявно преобразовывается) в казатель на
первый элемент массива;
2. Фиксированный массив знает свою длину, а указатель на него - нет;
*/

//void printSize(int array[]) // C++ неявно конвертирует параметр array[] в *array. Так лучше не делать
void printSize(int *array) {
    // Массив рассматривается как указатель
    cout << sizeof(array) << '\n'; // Размер указателя, а не длина массива!
}

// Параметр *ptr содержит копию адреса массива
void changeArray(int *ptr) {
    *ptr = 5; // Изменение элемента массива изменит фактический массив
}

int main() {
    int array[] {1, 2, 3, 4, 4, 9, 15, 25, 1, 2, 3, 4, 4, 9, 15, 25};
    cout << "длина массива в элементах: "
         << (sizeof(array) / sizeof(*array)) << " длина массива в байтах: "
         << sizeof(array) << '\n'; // 4 (int) * длину массива
    // С 64-битным исполняемым файлом указатель всегда будет занимать 64 бита (8 байт)
    // При передаче в функцию массива распадается на указатель
    printSize(array); // 8 байт - размер массива в байтах
    //cout << "Значение 0-го элемента: " << array[0] << '\n';
    cout << "Значение 0-го элемента: " << *array << '\n';
    changeArray(array);
    //cout << "Значение 0-го элемента: " << array[0] << '\n';
    cout << "Значение 0-го элемента: " << *array << '\n';
    return 0;
}
// Output
/*
длина массива в элементах: 16 длина массива в байтах: 64
8
Значение 0-го элемента: 1
Значение 0-го элемента: 5
*/
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- //
// END FILE
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- //