// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=//
// Адресная арифметика
// adressAriphm.cpp ReferencesPointers
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=//
#include<iostream>
using namespace std;
/*
1. Ссылка - не объект, а только другое имя уже существующего объекта.
2. Поскольку ссылки не объекты, нельзя определить ссылку на ссылку.
3. Поскольку ссылки не объекты, у них нет адресов.
4. Типы ссылки и объекта, на который она ссылается, должны совпадать точно.
5. Ссылка может быть связана только с объектом, а не с литералом (это элемент программы, который представляет значение).
6. Ссылки всегда следует инициализировать!
7. Ссылка не может быть изменена после инициализации.

1. Указатель - это настоящий объект!
2. Указатель всегда должен иметь тип.
3. Указатель содержит только адрес.
4. Тип указателя всегда должен соответствовать типу указываемой переменной.
5. Одному указателю можно присваивать разные значения.
6. Указатели в языке C++ по своей природе являются небезопасными.
7. С 64-битным исполняемым файлом указатель всегда будет занимать 64 бита (8 байт)
8. Указатель можно не инициализировать.
9. Между указателем и содержащимся в нём адресом нет жесткой связи
*/

int main() {
    short value = 8;
    short *ptr = &value;
    cout << ptr << '\n';
    cout << ptr+1 << '\n'; // Каждый следующий адрес с шагом 2 (размер short)
    cout << ptr+2 << '\n';
    cout << ptr+3 << '\n';
    int ivalue = 5;
    int *iptr = &ivalue;
    cout << ivalue << '\n';
    cout << iptr +1 << '\n'; // Каждый следующий адрес с шагом 4 (размер int)
    cout << iptr +2 << '\n';
    cout << iptr +3 << '\n';
    return 0;
}
// Output
/*
0x7ffc794bfdfa
0x7ffc794bfdfc
0x7ffc794bfdfe
0x7ffc794bfe00
5
0x7ffc794bfdf0
0x7ffc794bfdf4
0x7ffc794bfdf8
*/
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- //
// END FILE
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- //