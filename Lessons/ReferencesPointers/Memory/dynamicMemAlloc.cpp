//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
// Динамическое выделение памяти
// dynamicMemAlloc.cpp
// V 1.0
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
#include <iostream>
using namespace std;

int main() {
    //char mame[30]; // Можно надеятся, что пользователь введёт меньше 30 символов!
    //long array[1'000'000'000] {0}; // Ошибка сегментирования. Не хватает памяти в стеке (автоматической)!
    new int; // Диначически выделяем переменную и сразу отбрасываем результат, т.к. нигде его не сохраняем
    int *ptr = new int; // Динамически выделяем память для переменной и присваиваем ей адрес ptr, чтобы иметь к ней доступ
    cout << &ptr << endl; // Адрес типа int
    *ptr = 8; // Разыменовываем указатель и присваиваем значение только что выделенной памяти
    cout << ptr << '\t' << *ptr << '\t' << &ptr << endl;
    // Ещё примеры выделения (распределения памяти)
    // Выделение памяти с инициализацией
    int *ptr1 = new int (7); // Прямая инициализация переменной
    int *ptr2 = new int {8}; // uniform - инициализация
    cout << ptr1 << '\t' << ptr2 << endl;
    // Удаление указателей
    delete ptr;
    delete ptr1;
    delete ptr2;
    // Избавление от висячих указателей
    ptr = nullptr, ptr1 = nullptr, ptr2 = nullptr;
    return 0;
}
/*
Проверить потенциальные укрозы утечки памяти и висячие указатели можно командами:
1. clang-tidy main.cpp -- -Wall -std=c++14 -x c++
2. valgrind --leak-check=full ./main.bin
3. cppcheck main.cpp
*/
// Д.З.
// Output. Возможный результат
/*
0x7ffd87ef3c90
0xa13ed0        8       0x7ffd87ef3c90
0xa14300        0xa14320
*/
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
// End file
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-